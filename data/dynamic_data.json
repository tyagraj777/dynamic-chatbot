{"home": "\n\n\n\n\nSQLite Home Page\n\n\n\n\n\n\n\n\n\nSmall. Fast. Reliable.Choose any three.\n\n\n\nHome\nMenu\nAbout\nDocumentation\nDownload\nLicense\nSupport\nPurchase\n\nSearch\n\n\n\n\nAbout\nDocumentation\nDownload\nSupport\nPurchase\n\n\n\n\n\nSearch Documentation\nSearch Changelog\n\n\n\n\n\n\n\n\nCommon Links\n\n Features \n When to use SQLite \n Getting Started \n SQL Syntax\n\n Pragmas\n SQL functions\n Date & time functions\n Aggregate functions\n Window functions\n Math functions\n JSON functions\n\n\n C/C++ Interface Spec\n\n Introduction\n List of C-language APIs\n\n\n The TCL Interface Spec\n Quirks and Gotchas \n Frequently Asked Questions \n Commit History \n Prior Releases\n Bugs \n News \n\n\nWhat Is SQLite?\nSQLite is a C-language library that implements a\nsmall,\nfast,\nself-contained,\nhigh-reliability,\nfull-featured,\nSQL database engine.\nSQLite is the most used database engine in the world.\nSQLite is built into all mobile phones and most computers and\ncomes bundled inside countless other applications that people\nuse every day.\nMore Information...\n\nThe SQLite file format is stable, cross-platform, and\nbackwards compatible and the developers pledge to keep it\nthat way through the year 2050.  SQLite database\nfiles are commonly used as containers to transfer rich\ncontent between systems\n[1]\n[2]\n[3]\nand as a long-term archival format\nfor data\n[4].\nThere are over 1 trillion (1e12)\nSQLite databases in active use\n[5].\n\n\nSQLite source code\nis in the public-domain and is free to\neveryone to use for any purpose.\n\nLatest Release\nVersion 3.49.1 (2025-02-18).\nDownload\nPrior Releases\n\nCommon Links\n\n Features \n When to use SQLite \n Getting Started \n SQL Syntax\n\n Pragmas\n SQL functions\n Date & time functions\n Aggregate functions\n Window functions\n Math functions\n JSON functions\n\n\n C/C++ Interface Spec\n\n Introduction\n List of C-language APIs\n\n\n The TCL Interface Spec\n Quirks and Gotchas \n Frequently Asked Questions \n Commit History \n Prior Releases\n Bugs \n News \n\n\n\n\nOngoing development and support of SQLite is made possible in part\nby SQLite Consortium members, including:\n\n\n\n\n\n\nThis page last modified on  2025-02-25 16:11:29 UTC \n", "faqs": "\n\n\n\n\nSQLite Frequently Asked Questions\n\n\n\n\n\n\n\n\n\nSmall. Fast. Reliable.Choose any three.\n\n\n\nHome\nMenu\nAbout\nDocumentation\nDownload\nLicense\nSupport\nPurchase\n\nSearch\n\n\n\n\nAbout\nDocumentation\nDownload\nSupport\nPurchase\n\n\n\n\n\nSearch Documentation\nSearch Changelog\n\n\n\n\n\n\n\nFrequently Asked QuestionsHow do I create an AUTOINCREMENT field?What datatypes does SQLite support?SQLite lets me insert a string into a database column of type integer!Why doesn't SQLite allow me to use '0' and '0.0' as the primary\n  key on two different rows of the same table?Can multiple applications or multiple instances of the same\n  application access a single database file at the same time?Is SQLite threadsafe?How do I list all tables/indices contained in an SQLite databaseAre there any known size limits to SQLite databases?What is the maximum size of a VARCHAR in SQLite?Does SQLite support a BLOB type?How do I add, delete or rename columns from an existing table in SQLite?I deleted a lot of data but the database file did not get any\n  smaller.  Is this a bug?Can I use SQLite in my commercial product without paying royalties?How do I use a string literal that contains an embedded single-quote (')\n  character?What is an SQLITE_SCHEMA error, and why am I getting one?I get some compiler warnings when I compile SQLite.\n  Isn't this a problem?  Doesn't it indicate poor code quality?Case-insensitive matching of Unicode characters does not work.INSERT is really slow - I can only do few dozen INSERTs per secondI accidentally deleted some important information from my SQLite database.\n  How can I recover it?What is an SQLITE_CORRUPT error?  What does it mean for the database\n  to be \"malformed\"? Why am I getting this error?Does SQLite support foreign keys?I get a compiler error if I use the SQLITE_OMIT_... \n  compile-time options when building SQLite.My WHERE clause expression column1=\"column1\" does not work.\n  It causes every row of the table to be returned, not just the rows\n  where column1 has the value \"column1\".How are the syntax diagrams (a.k.a. \"railroad\" diagrams) for\n  SQLite generated?The SQL standard requires that a UNIQUE constraint be enforced even if\n  one or more of the columns in the constraint are NULL, but SQLite does\n  not do this.  Isn't that a bug?What is the Export Control Classification Number (ECCN) for SQLite?My query does not return the column name that I expect.  Is this a bug?Where did my database go? (Or: How did my database become empty?)\n(1) How do I create an AUTOINCREMENT field?\nShort answer: A column declared INTEGER PRIMARY KEY will\n  autoincrement.\nLonger answer:\n  If you declare a column of a table to be INTEGER PRIMARY KEY, then\n  whenever you insert a NULL\n  into that column of the table, the NULL is automatically converted\n  into an integer which is one greater than the largest value of that\n  column over all other rows in the table, or 1 if the table is empty.\n  Or, if the largest existing integer key 9223372036854775807 is in use then an\n  unused key value is chosen at random.\n  For example, suppose you have a table like this:\n\nCREATE TABLE t1(\n  a INTEGER PRIMARY KEY,\n  b INTEGER\n);\n\nWith this table, the statement\n\nINSERT INTO t1 VALUES(NULL,123);\n\nis logically equivalent to saying:\n\nINSERT INTO t1 VALUES((SELECT max(a) FROM t1)+1,123);\n\nThere is a function named\n  sqlite3_last_insert_rowid() which will return the integer key\n  for the most recent insert operation.\nNote that the integer key is one greater than the largest\n  key that was in the table just prior to the insert.  The new key\n  will be unique over all keys currently in the table, but it might\n  overlap with keys that have been previously deleted from the\n  table.  To create keys that are unique over the lifetime of the\n  table, add the AUTOINCREMENT keyword to the INTEGER PRIMARY KEY\n  declaration.  Then the key chosen will be one more than the\n  largest key that has ever existed in that table.  If the largest\n  possible key has previously existed in that table, then the INSERT\n  will fail with an SQLITE_FULL error code.\n\n(2) What datatypes does SQLite support?\nSQLite uses dynamic typing.  Content can be stored as INTEGER,\n  REAL, TEXT, BLOB, or as NULL.\n\n(3) SQLite lets me insert a string into a database column of type integer!\nThis is a feature, not a bug.  SQLite uses dynamic typing. \n  It does not enforce data type  constraints.  Data of any type can\n  (usually) be inserted into any column.  You can put arbitrary length\n  strings into integer columns, floating point numbers in boolean columns,\n  or dates in character columns.  The datatype you assign to a column in the\n  CREATE TABLE command does not restrict what data can be put into\n  that column.  Every column is able to hold\n  an arbitrary length string.  (There is one exception: Columns of\n  type INTEGER PRIMARY KEY may only hold a 64-bit signed integer.\n  An error will result\n  if you try to put anything other than an integer into an\n  INTEGER PRIMARY KEY column.)\nBut SQLite does use the declared type of a column as a hint\n  that you prefer values in that format.  So, for example, if a\n  column is of type INTEGER and you try to insert a string into\n  that column, SQLite will attempt to convert the string into an\n  integer.  If it can, it inserts the integer instead.  If not,\n  it inserts the string.  This feature is called type affinity.\n  \n\n(4) Why doesn't SQLite allow me to use '0' and '0.0' as the primary\n  key on two different rows of the same table?\nThis problem occurs when your primary key is a numeric type.  Change the\n  datatype of your primary key to TEXT and it should work.\nEvery row must have a unique primary key.  For a column with a\n  numeric type, SQLite thinks that '0' and '0.0' are the\n  same value because they compare equal to one another numerically.\n  (See the previous question.)  Hence the values are not unique.\n\n(5) Can multiple applications or multiple instances of the same\n  application access a single database file at the same time?\nMultiple processes can have the same database open at the same\n  time.  Multiple processes can be doing a SELECT\n  at the same time.  But only one process can be making changes to\n  the database at any moment in time, however.\nSQLite uses reader/writer locks to control access to the database.\n  (Under Win95/98/ME which lacks support for reader/writer locks, a\n  probabilistic simulation is used instead.)\n  But use caution: this locking mechanism might\n  not work correctly if the database file is kept on an NFS filesystem.\n  This is because fcntl() file locking is broken on many NFS implementations.\n  You should avoid putting SQLite database files on NFS if multiple\n  processes might try to access the file at the same time.  On Windows,\n  Microsoft's documentation says that locking may not work under FAT\n  filesystems if you are not running the Share.exe daemon.  People who\n  have a lot of experience with Windows tell me that file locking of\n  network files is very buggy and is not dependable.  If what they\n  say is true, sharing an SQLite database between two or more Windows\n  machines might cause unexpected problems.\nWe are aware of no other embedded SQL database engine that\n  supports as much concurrency as SQLite.  SQLite allows multiple processes\n  to have the database file open at once, and for multiple processes to\n  read the database at once.  When any process wants to write, it must\n  lock the entire database file for the duration of its update.  But that\n  normally only takes a few milliseconds.  Other processes just wait on\n  the writer to finish then continue about their business.  Other embedded\n  SQL database engines typically only allow a single process to connect to\n  the database at once.\nHowever, client/server database engines (such as PostgreSQL, MySQL,\n  or Oracle) usually support a higher level of concurrency and allow\n  multiple processes to be writing to the same database at the same time.\n  This is possible in a client/server database because there is always a\n  single well-controlled server process available to coordinate access.\n  If your application has a need for a lot of concurrency, then you should\n  consider using a client/server database.  But experience suggests that\n  most applications need much less concurrency than their designers imagine.\n  \nWhen SQLite tries to access a file that is locked by another\n  process, the default behavior is to return SQLITE_BUSY.  You can\n  adjust this behavior from C code using the\n  sqlite3_busy_handler() or sqlite3_busy_timeout()\n  API functions.\n\n(6) Is SQLite threadsafe?\nThreads are evil.\n  Avoid them.\n\n  SQLite is threadsafe.  We make this concession since many users choose\n  to ignore the advice given in the previous paragraph.\n  But in order to be thread-safe, SQLite must be compiled\n  with the SQLITE_THREADSAFE preprocessor macro set to 1.  Both the Windows\n  and Linux precompiled binaries in the distribution are compiled this way.\n  If you are unsure if the SQLite library you are linking against is compiled\n  to be threadsafe you can call the sqlite3_threadsafe()\n  interface to find out.\n  \nSQLite is threadsafe because it uses mutexes to serialize\n  access to common data structures.  However, the work of acquiring and\n  releasing these mutexes will slow SQLite down slightly.  Hence, if you\n  do not need SQLite to be threadsafe, you should disable the mutexes\n  for maximum performance.  See the threading mode documentation for\n  additional information.\nUnder Unix, you should not carry an open SQLite database across\n  a fork() system call into the child process.\n\n(7) How do I list all tables/indices contained in an SQLite database\nIf you are running the sqlite3 command-line access program\n  you can type \".tables\" to get a list of all tables.  Or you\n  can type \".schema\" to see the complete database schema including\n  all tables and indices.  Either of these commands can be followed by\n  a LIKE pattern that will restrict the tables that are displayed.\nFrom within a C/C++ program (or a script using Tcl/Ruby/Perl/Python\n  bindings) you can get access to table and index names by doing a SELECT\n  on a special table named \"SQLITE_SCHEMA\".  Every SQLite database\n  has an SQLITE_SCHEMA table that defines the schema for the database.\n  The SQLITE_SCHEMA table looks like this:\n\nCREATE TABLE sqlite_schema (\n  type TEXT,\n  name TEXT,\n  tbl_name TEXT,\n  rootpage INTEGER,\n  sql TEXT\n);\n\nFor tables, the type field will always be 'table' and the\n  name field will be the name of the table.  So to get a list of\n  all tables in the database, use the following SELECT command:\n\nSELECT name FROM sqlite_schema\nWHERE type='table'\nORDER BY name;\n\nFor indices, type is equal to 'index', name is the\n  name of the index and tbl_name is the name of the table to which\n  the index belongs.  For both tables and indices, the sql field is\n  the text of the original CREATE TABLE or CREATE INDEX statement that\n  created the table or index.  For automatically created indices (used\n  to implement the PRIMARY KEY or UNIQUE constraints) the sql field\n  is NULL.\nThe SQLITE_SCHEMA table cannot be modified using UPDATE, INSERT, \n  or DELETE (except under\n  extraordinary conditions).  \n  The SQLITE_SCHEMA table is automatically updated by commands like\n  CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX.\nTemporary tables do not appear in the SQLITE_SCHEMA table.  Temporary\n  tables and their indices and triggers occur in another special table\n  named SQLITE_TEMP_SCHEMA.  SQLITE_TEMP_SCHEMA works just like SQLITE_SCHEMA\n  except that it is only visible to the application that created the \n  temporary tables.  To get a list of all tables, both permanent and\n  temporary, one can use a command similar to the following:\n\nSELECT name FROM \n   (SELECT * FROM sqlite_schema UNION ALL\n    SELECT * FROM sqlite_temp_schema)\nWHERE type='table'\nORDER BY name\n\n\n(8) Are there any known size limits to SQLite databases?\nSee limits.html for a full discussion of\n  the limits of SQLite.\n\n(9) What is the maximum size of a VARCHAR in SQLite?\nSQLite does not enforce the length of a VARCHAR.  You can declare\n  a VARCHAR(10) and SQLite will be happy to store a 500-million character\n  string there.  And it will keep all 500-million characters intact.\n  Your content is never truncated.  SQLite understands the column type\n  of \"VARCHAR(N)\" to be the same as \"TEXT\", regardless of the value\n  of N.\n  \n\n(10) Does SQLite support a BLOB type?\nSQLite allows you to store BLOB data in any \n  column, even columns that are declared to hold some other type.\n  BLOBs can even be used as PRIMARY KEYs.\n\n(11) How do I add, delete or rename columns from an existing table in SQLite?\nSQLite has limited ALTER TABLE support that you can use to\n  add, rename or drop columns or to change the name of a table\n  as detailed at ALTER TABLE.\nIf you want to make more complex changes in the structure or\n  constraints of a table or its columns, you will have to recreate it.\n  You can save existing data to a temporary table, drop the\n  old table, create the new table, then copy the data back in from\n  the temporary table. See \n  Making Other Kinds Of Table Schema Changes for procedure.\n\n(12) I deleted a lot of data but the database file did not get any\n  smaller.  Is this a bug?\nNo.  When you delete information from an SQLite database, the\n  unused disk space is added to an internal \"free-list\" and is reused\n  the next time you insert data.  The disk space is not lost.  But\n  neither is it returned to the operating system.\nIf you delete a lot of data and want to shrink the database file,\n  run the VACUUM command.\n  VACUUM will reconstruct\n  the database from scratch.  This will leave the database with an empty\n  free-list and a file that is minimal in size.  Note, however, that the\n  VACUUM can take some time to run and it can use up to twice\n  as much temporary disk space as the original file while it is running.\n  \nAn alternative to using the VACUUM command\n  is auto-vacuum mode, enabled using the \n  auto_vacuum pragma.\n\n(13) Can I use SQLite in my commercial product without paying royalties?\nYes.  SQLite is in the \n  public domain.  No claim of ownership is made\n  to any part of the code.  You can do anything you want with it.\n\n(14) How do I use a string literal that contains an embedded single-quote (')\n  character?\nThe SQL standard specifies that single-quotes in strings are escaped\n  by putting two single quotes in a row.  SQL works like the Pascal programming\n  language in this regard. Example:\n  \n\n    INSERT INTO xyz VALUES('5 O''clock');\n  \n\n(15) What is an SQLITE_SCHEMA error, and why am I getting one?\nAn SQLITE_SCHEMA error is returned when a \n  prepared SQL statement is no longer valid and cannot be executed.\n  When this occurs, the statement must be recompiled from SQL using \n  the sqlite3_prepare() API.\n  An SQLITE_SCHEMA error can only occur when using the sqlite3_prepare(),\n  and sqlite3_step() interfaces to run SQL.\n  You will never receive an SQLITE_SCHEMA error from\n  sqlite3_exec().  Nor will you receive an error if you\n  prepare statements using sqlite3_prepare_v2() instead of\n  sqlite3_prepare().\nThe sqlite3_prepare_v2() interface creates a\n  prepared statement that will automatically recompile itself if\n  the schema changes.  The easiest way to deal with\n  SQLITE_SCHEMA errors is to always use sqlite3_prepare_v2()\n  instead of sqlite3_prepare().\n\n(17) I get some compiler warnings when I compile SQLite.\n  Isn't this a problem?  Doesn't it indicate poor code quality?\nQuality assurance in SQLite is done using \n  full-coverage testing,\n  not by compiler warnings or other static code analysis tools.\n  In other words, we verify that SQLite actually gets the\n  correct answer, not that it merely satisfies stylistic constraints.\n  Most of the SQLite code base is devoted purely to testing.\n  The SQLite test suite runs tens of thousands of separate test cases and\n  many of those test cases are parameterized so that hundreds of millions\n  of tests involving billions of SQL statements are run and evaluated\n  for correctness prior to every release.  The developers use code\n  coverage tools to verify that all paths through the code are tested.\n  Whenever a bug is found in SQLite, new test cases are written to\n  exhibit the bug so that the bug cannot recur undetected in the future.\nDuring testing, the SQLite library is compiled with special\n  instrumentation that allows the test scripts to simulate a wide\n  variety of failures in order to verify that SQLite recovers\n  correctly.  Memory allocation is carefully tracked and no memory\n  leaks occur, even following memory allocation failures.  A custom\n  VFS layer is used to simulate operating system crashes and power\n  failures in order to ensure that transactions are atomic across\n  these events.  A mechanism for deliberately injecting I/O errors\n  shows that SQLite is resilient to such malfunctions.  (As an\n  experiment, try inducing these kinds of errors on other SQL database\n  engines and see what happens!)\nWe also run SQLite using Valgrind\n  on Linux and verify that it detects no problems.\nSome people say that we should eliminate all warnings because\n  benign warnings mask real warnings that might arise in future changes.\n  This is true enough.  But in reply, the developers observe that all\n  warnings have already been fixed in the builds\n  used for SQLite development (various versions of GCC, MSVC,\n  and clang).\n  Compiler warnings usually only arise from compilers or compile-time \n  options that the SQLite developers do not use themselves.\n\n(18) Case-insensitive matching of Unicode characters does not work.\nThe default configuration of SQLite only supports case-insensitive\n  comparisons of ASCII characters.  The reason for this is that doing\n  full Unicode case-insensitive comparisons and case conversions \n  requires tables and logic that would nearly double the size of\n  the SQLite library.  The\n  SQLite developers reason that any application that needs full\n  Unicode case support probably already has the necessary tables and\n  functions and so SQLite should not take up space to \n  duplicate this ability.\nInstead of providing full Unicode case support by default, \n  SQLite provides the ability to link against external\n  Unicode comparison and conversion routines.\n  The application can overload the built-in NOCASE collating\n  sequence (using sqlite3_create_collation()) and the built-in\n  like(), upper(), and lower() functions\n  (using sqlite3_create_function()).  \n  The SQLite source code includes an \"ICU\" extension that does \n  these overloads.  Or, developers can write their own overloads\n  based on their own Unicode-aware comparison routines already\n  contained within their project.\n\n(19) INSERT is really slow - I can only do few dozen INSERTs per second\nActually, SQLite will easily do 50,000 or more INSERT statements per second\n  on an average desktop computer.  But it will only do a few dozen transactions\n  per second.  Transaction speed is limited by the rotational speed of\n  your disk drive.  A transaction normally requires two complete rotations\n  of the disk platter, which on a 7200RPM disk drive limits you to about\n  60 transactions per second.\n\n  Transaction speed is limited by disk drive speed because (by default)\n  SQLite actually waits until the data really is safely stored on the disk\n  surface before the transaction is complete.  That way, if you suddenly lose\n  power or if your OS crashes, your data is still safe.  For details, \n  read about atomic commit in SQLite..\n\n  By default, each INSERT statement is its own transaction.  But if you\n  surround multiple INSERT statements with BEGIN...COMMIT then all the\n  inserts are grouped into a single transaction.  The time needed to commit\n  the transaction is amortized over all the enclosed insert statements and\n  so the time per insert statement is greatly reduced.\n\n  Another option is to run PRAGMA synchronous=OFF.  This command will\n  cause SQLite to not wait on data to reach the disk surface, which will make\n  write operations appear to be much faster.  But if you lose power in the\n  middle of a transaction, your database file might go corrupt.\n\n  Update 2024-11-19:  The text above is a really old answer.  \n  SQLite will do far more than 50K inserts/second now, and everybody uses SSD\n  nowadays, making the performance faster still.  But the gist of the answer\n  above remains correct:  Putting multiple operations inside a single\n  transaction can improve performance dramatically by avoiding the overhead\n  of transaction control after each individual operation.\n\n(20) I accidentally deleted some important information from my SQLite database.\n  How can I recover it?\nIf you have a backup copy of your database file, recover the information\n  from your backup.\n\n  If you do not have a backup, recovery is very difficult.  You might\n  be able to find partial string data in a binary dump of the raw database\n  file.  Recovering numeric data might also be possible given special tools,\n  though to our knowledge no such tools exist.  SQLite is sometimes compiled\n  with the SQLITE_SECURE_DELETE option which overwrites all deleted content\n  with zeros.  If that is the case then recovery is clearly impossible.\n  Recovery is also impossible if you have run VACUUM since the data was\n  deleted.  If SQLITE_SECURE_DELETE is not used and VACUUM has not been run,\n  then some of the deleted content might still be in the database file, in\n  areas marked for reuse.  But, again, there exist no procedures or tools\n  that we know of to help you recover that data.\n\n(21) What is an SQLITE_CORRUPT error?  What does it mean for the database\n  to be \"malformed\"? Why am I getting this error?\nAn SQLITE_CORRUPT error is returned when SQLite detects an error\n  in the structure, format, or other control elements of the\n  database file.\nSQLite does not corrupt database files without external help.\n  If your application crashes in the middle of an\n  update, your data is safe.  The database is safe even if your OS\n  crashes or takes a power loss.  The crash-resistance of SQLite has\n  been extensively studied and tested and is attested by years of real-world \n  experience by billions of users.\nThat said, there are a number of things that external programs or bugs\n  in your hardware or OS can do to corrupt a database file.  See\n  How To Corrupt An SQLite Database File for\n  further information.\n\n  You can use PRAGMA integrity_check \n  to do a thorough but time intensive test of the database integrity.\nYou can use PRAGMA quick_check to do a faster \n  but less thorough test of the database integrity.\nDepending how badly your database is corrupted, you may be able to \n  recover some of the data by using the CLI to dump the schema and contents\n  to a file and then recreate.  Unfortunately, once humpty-dumpty falls off \n  the wall, it is generally not possible to put him back together again.\n\n(22) Does SQLite support foreign keys?\n\n  As of version 3.6.19 (2009-10-14), \n  SQLite supports foreign key constraints.  But enforcement\n  of foreign key constraints is turned off by default (for backwards compatibility).\n  To enable foreign key constraint enforcement, run \n  PRAGMA foreign_keys=ON or compile with\n  -DSQLITE_DEFAULT_FOREIGN_KEYS=1.\n\n(23) I get a compiler error if I use the SQLITE_OMIT_... \n  compile-time options when building SQLite.\nThe SQLITE_OMIT_... compile-time options only work\n  when building from canonical source files.  They do not work\n  when you build from the SQLite amalgamation or from the pre-processed\n  source files.\n\n  It is possible to build a special amalgamation that will work with\n  a predetermined set of SQLITE_OMIT_... options.  Instructions for doing\n  so can be found with the SQLITE_OMIT_... documentation.\n\n(24) My WHERE clause expression column1=\"column1\" does not work.\n  It causes every row of the table to be returned, not just the rows\n  where column1 has the value \"column1\".\nUse single-quotes, not double-quotes, around string literals in SQL.\n  This is what the SQL standard requires.  Your WHERE clause expression\n  should read: column1='column1'\nSQL uses double-quotes around identifiers (column or table names) that\n  contains special characters or which are keywords.  So double-quotes are\n  a way of escaping identifier names.  Hence, when you say\n  column1=\"column1\" that is equivalent to \n  column1=column1 which is obviously always true.\n\n(25) How are the syntax diagrams (a.k.a. \"railroad\" diagrams) for\n  SQLite generated?\nEach diagram is hand-written using the Pikchr\n  diagramming language.  These hand-written specifications are converted into\n  SVG and inserted inline in the HTML files as part of the documentation build process.\n  \n  Many historical versions of the SQLite documentation used a different process for\n  generating the syntax diagrams.  The historical process was based on Tcl/Tk and is\n  described  at http://wiki.tcl-lang.org/21708.  The newer Pikchr-based syntax diagrams\n  first landed on trunk on 2020-09-26.\n\n(26) The SQL standard requires that a UNIQUE constraint be enforced even if\n  one or more of the columns in the constraint are NULL, but SQLite does\n  not do this.  Isn't that a bug?\nPerhaps you are referring to the following statement from SQL92:\n\n  \n  A unique constraint is satisfied if and only if no two rows in a\n  table have the same non-null values in the unique columns. \n  \n\n  That statement is ambiguous, having at least two possible interpretations:\n\n  \nA unique constraint is satisfied if and only if no two rows in a\n  table have the same values and have non-null values in the unique columns.\n  A unique constraint is satisfied if and only if no two rows in a \n  table have the same values in the subset of unique columns that are not null.\n  \n\n  SQLite follows interpretation (1), as does PostgreSQL, MySQL, Oracle,\n  and Firebird.  It is true that Informix and Microsoft SQL Server use\n  interpretation (2), however we the SQLite developers hold that \n  interpretation (1) is the most natural reading \n  of the requirement and we also want to maximize compatibility with other\n  SQL database engines, and most other database engines also go with (1),\n  so that is what SQLite does.\n\n(27) What is the Export Control Classification Number (ECCN) for SQLite?\nAfter careful review of the Commerce Control List (CCL), we are convinced\n  that the core public-domain SQLite source code is not described by any ECCN,\n  hence the ECCN should be reported as EAR99.\n\n  The above is true for the core public-domain SQLite.  If you extend\n  SQLite by adding new code, or if you statically link SQLite with your\n  application, that might change the ECCN in your particular case.\n\n(28) My query does not return the column name that I expect.  Is this a bug?\nIf the columns of your result set are named by AS clauses, then SQLite\n  is guaranteed to use the identifier to the right of the AS keyword as the\n  column name.  If the result set does not use an AS clause, then SQLite\n  is free to name the column anything it wants.\n  See the sqlite3_column_name() documentation for further information.\n\n(29) Where did my database go? (Or: How did my database become empty?)\nUnless opened with flags to prevent it, a SQLite database is created\n  if it does not already exist. Newly created databases are initially empty.\n  This can confuse people who inadvertantly open different database files\n  in different contexts, due to either a typo in the filename\n  or use of a relative pathname that is used with\n  differing current directories for the opening processes.\n\nThis page last modified on  2024-11-26 23:53:35 UTC \n", "products": "\n\n\n\n\nSQLite Pro Support\n\n\n\n\n\n\n\n\n\nSmall. Fast. Reliable.Choose any three.\n\n\n\nHome\nMenu\nAbout\nDocumentation\nDownload\nLicense\nSupport\nPurchase\n\nSearch\n\n\n\n\nAbout\nDocumentation\nDownload\nSupport\nPurchase\n\n\n\n\n\nSearch Documentation\nSearch Changelog\n\n\n\n\n\n\n\n\nProfessional Support & Extension Products\n\nSupport\n(details below)\n\n\n1.Public Forum. \n  Help and advice from a world-wide community of experts.\n\nFree\nMore Info\nRecent Posts\n\n2.Annual Maintenance Subscription. \n  Private, expert email advice from the developers of SQLite.\n\n$1500/year\nMore Info\nPurchase\n\n3.Technical Support. \n  High-priority email and phone support directly from the SQLite developers.\n  Guaranteed response time available as an option.\n\n$8K-85K/year\nMore Info\nRequest A Quote\n\n4.SQLite Consortium Membership. \n  Premium enterprise support including on-site visits and\n  access to all proprietary extensions and test suites.\n\n$120K/year\nMore Info\nRequest A Quote\n\n\n\n\n\nPublic Forum. \n  Help and advice from a world-wide community of experts.\n\nCost: Free\nMore Info\nRecent Posts\n\n\nAnnual Maintenance Subscription. \n  Private, expert email advice from the developers of SQLite.\n\nCost: $1500/year\nMore Info\nPurchase\n\n\nTechnical Support. \n  High-priority email and phone support directly from the SQLite developers.\n  Guaranteed response time available as an option.\n\nCost: $8K-85K/year\nMore Info\nRequest A Quote\n\n\nSQLite Consortium Membership. \n  Premium enterprise support including on-site visits and\n  access to all proprietary extensions and test suites.\n\nCost: $120K/year\nMore Info\nRequest A Quote\n\n\nLicenses\n(details below)\n\n\n5.SQLite License. \n  Warranty of title and perpetual right-to-use for the SQLite source code.\n\n$6000 one time fee\nMore Info\nPurchase\n\n6.SQLite Encryption Extension (SEE) source code. \n   A drop-in replacement for public-domain SQLite C source code that has\n   the added ability to read/write AES-encrypted databases.\n\n$2000 one time fee\nMore Info\nPurchase\n\n7.Compressed And Encrypted Read-Only Database (CEROD). \n   A drop-in replacement for public-domain SQLite source code\n   that has the added ability to read database that has been both\n   compressed and encrypted.\n\n$2000 one time fee\nMore Info\nBuy Now!\n\n8.The ZIPVFS Read/Write Compressed Database Extension. \n   The ZIPVFS extension automatically compresses and encrypts\n   your data as it is written to disk, and decompressed and decrypts\n   it while reading.\n\n$4000 one time fee\nMore Info\nBuy Now!\n\n\n\n\n\nSQLite License. \n  Warranty of title and perpetual right-to-use for the SQLite source code.\n\nCost: $6000 one time fee\nMore Info\nPurchase\n\n\nSQLite Encryption Extension (SEE) source code. \n   A drop-in replacement for public-domain SQLite C source code that has\n   the added ability to read/write AES-encrypted databases.\n\nCost: $2000 one time fee\nMore Info\nPurchase\n\n\nCompressed And Encrypted Read-Only Database (CEROD). \n   A drop-in replacement for public-domain SQLite source code\n   that has the added ability to read database that has been both\n   compressed and encrypted.\n\nCost: $2000 one time fee\nMore Info\nBuy Now!\n\n\nThe ZIPVFS Read/Write Compressed Database Extension. \n   The ZIPVFS extension automatically compresses and encrypts\n   your data as it is written to disk, and decompressed and decrypts\n   it while reading.\n\nCost: $4000 one time fee\nMore Info\nBuy Now!\n\n\nSpecial Services\n(details below)\n\n\n9.TH3 Testing Support. \n  The TH3 test harness\n  is an aviation-grade test suite for SQLite. SQLite developers\n  can run TH3 on specialized hardware and/or using specialized\n  compile-time options, according to customer specification,\n  either remotely or on customer premises. Pricing for this\n  services is on a case-by-case basis depending on requirements.\n\ncall\nMore Info\nRequest A Quote\n\n\n\n\n\nTH3 Testing Support. \n  The TH3 test harness\n  is an aviation-grade test suite for SQLite. SQLite developers\n  can run TH3 on specialized hardware and/or using specialized\n  compile-time options, according to customer specification,\n  either remotely or on customer premises. Pricing for this\n  services is on a case-by-case basis depending on requirements.\n\nCost: call\nMore Info\nRequest A Quote\n\n\n\nFurther Information\nSQLite is free and works great.\nMost people use SQLite without\nany kind of license or support.\nFree support for SQLite is available on the public\nSQLite Forum.\nThe forum is monitored by a large\ncommunity of experts, including the core SQLite development team,\nwho are able to resolve just about\nany problems with SQLite that you are likely to have.\nIf you do not want to discuss your issues on a public and open forum, an\nAnnual Maintenance\nSubscription or \"AMS\" might\nserve your needs better.\nAn AMS entitles you to private email support directly from the developers of\nSQLite.  The level of support with an AMS is similar to the support one\ngets from the public forum except that an AMS includes a unilateral\npromise of non-disclosure, so with an AMS you can discuss your issues\nwith the SQLite developers in private, without the whole world watching.\nAn AMS costs $1500 per year.\nUsers with more advanced support needs can opt for a\nTechnical Support\nAgreement.\nTechnical support agreements are customized to the needs of each\nindividual client, but generally include direct telephone support\nand priority handling of issues and bugs.  Guaranteed response time\nis available as an option.  The cost of\ntechnical support varies but is generally\nin the range of $8000 to $35000 per year.\nIf SQLite is \"mission critical\" to your company, then you may\nwant to become an\nSQLite Consortium\nMember.  The SQLite\nConsortium is a collaboration of companies who sponsor ongoing development\nof SQLite in exchange for enterprise-level technical support, on-site\nvisits from the SQLite developers, unlimited access to all licensed\nproducts, and strong guarantees that SQLite will remain in the public\ndomain, free and independent, and will not come under the control of\na competitor.\n\nSoftware Licenses\nThe SQLite source code is in the\npublic domain,\nand is free for use\nby anyone and for any purpose.  No license is required.  However, some\nusers desire a license so that they can have warranty of title, or just\nbecause their company lawyers say they need one.  A\nperpetual license\nand warranty of title\nfor the core SQLite source code is available for this purpose.\nThe\nSQLite Encryption\nExtension (SEE),\nthe ZIPVFS Extension,\nand the Compressed and\nEncrypted ReadOnly Database (CEROD) extension are enhanced versions\nof SQLite that handle encrypted\nand/or compressed databases.  SEE can read and write encrypted databases.\nSEE encrypts all database content, including metadata, so that the database\nfile appears as white noise.  ZIPVFS\ncompresses the database on-the-fly using application-supplied\ncompression and decompression functions.\nCEROD reads a compressed database that is\nalso optionally encrypted.  All of SEE, ZIPVFS, and CEROD are\nsupplied in source code form only; the licensee is responsible for\ncompiling the products for their chosen platform.  It is not difficult\nto compile any of these extension.  All products come in the form of an\n{amalgamated source file}\nnamed \"sqlite3.c\".  So compiling SEE, ZIPVFS, or CEROD into an application\nis simply a matter of substituting the SEE-, ZIPVFS-, or CEROD-enabled sqlite3.c\nsource file in place of the public-domain sqlite3.c source file and recompiling.\nLicenses for SEE, ZIPVFS, and CEROD are perpetual.\nAll three extension can read and write ordinary,\nuncompressed and unencrypted database files.\n\nTesting Services\nThe Test Harness #3 (TH3) is\na suite of test cases for SQLite that provide 100% branch test coverage\n(and 100% modified condition/decision coverage) for the core SQLite in\nan as-deployed configuration using only published and documented interfaces.\nTH3 is designed for use with embedded devices, and is compatible with\nDO-178B.  Every release of the public-domain SQLite is tested using TH3,\nand so all users benefit from the TH3 tests.  But the TH3 tests are not\nthemselves public.  Hardware or system manufactures who want to have\nTH3 test run on their systems can negotiate a service agreement to have\nthe SQLite Developers run those tests.\nAbout The SQLite Team\nPaid support options and products are provided by\nHipp, Wyrick & Company, Inc., (Hwaci), a\nGeorgia\ncorporation\nwith headquarters in\n\nCharlotte, North Carolina and has been in business since\n1992.\nHwaci has an international team of\nemployees and associates representing the best available talent.\nWe are a 100% engineering company.  There is\nno sales staff.\nOur goal is to provide outstanding service and honest advice\nwithout spin or sales-talk.\nHwaci is a small company but it is\nalso closely held and debt-free and has low\nfixed costs, which means that it is largely immune to buy-outs,\ntake-overs, and market down-turns.  Hwaci intends to\ncontinue operating in its current form, and at roughly its current\nsize until at least the year 2050.\nWe expect to be here when you need us,\neven if that need is many years in the future.\n\nThis page last modified on  2025-02-28 23:16:02 UTC \n", "services": "Not Found\nDocument Not Found\nThe document /purchase/index.html is not available on this server\n\n", "about": "\n\n\n\n\nAbout SQLite\n\n\n\n\n\n\n\n\n\nSmall. Fast. Reliable.Choose any three.\n\n\n\nHome\nMenu\nAbout\nDocumentation\nDownload\nLicense\nSupport\nPurchase\n\nSearch\n\n\n\n\nAbout\nDocumentation\nDownload\nSupport\nPurchase\n\n\n\n\n\nSearch Documentation\nSearch Changelog\n\n\n\n\n\n\n\nAbout SQLite\n\nExecutive Summary\n\n Full-featured SQL\n Billions and billions of deployments\n Single-file database\n Public domain source code\n All source code in one file (sqlite3.c)\n Small footprint\n Max DB size: 281 terabytes\n     (248 bytes)\n Max row size: 1 gigabyte\n Faster than direct file I/O\n Aviation-grade quality and testing\n Zero-configuration\n ACID transactions, even after power loss\n Stable, enduring file format\n Extensive, detailed documentation\n Long-term support\n\nSQLite is an in-process library that implements a\nself-contained, \nserverless,\nzero-configuration,\ntransactional\nSQL database engine.\nThe code for SQLite is in the\npublic domain and is thus free for\nuse for any purpose, commercial or private.\nSQLite is the most widely deployed database in the world\nwith more applications than we can\ncount, including several high-profile projects.\nSQLite is an embedded SQL database engine.\nUnlike most other SQL databases, SQLite does not have a separate\nserver process.  SQLite reads and writes directly to ordinary disk\nfiles.  A complete SQL database with multiple tables, indices,\ntriggers, and views, is contained in a single disk file.\nThe database file format is cross-platform - you can freely copy a database\nbetween 32-bit and 64-bit systems or between \nbig-endian and\nlittle-endian\narchitectures.  These features make SQLite a popular choice as\nan Application File Format.  SQLite database files are a\nrecommended storage format by the US Library of Congress.\nThink of SQLite not as a replacement for \nOracle but\nas a replacement for fopen()\nSQLite is a compact library.\nWith all features enabled, the library size can be less than 750KiB,\ndepending on the target platform and compiler optimization settings.\n(64-bit code is larger.  And some compiler optimizations\nsuch as aggressive function inlining and loop unrolling can cause the\nobject code to be much larger.)\nThere is a tradeoff between memory usage and speed.  \nSQLite generally runs faster the more memory\nyou give it.  Nevertheless, performance is usually quite good even\nin low-memory environments.  Depending on how it is used, SQLite can be\nfaster than direct filesystem I/O.\nSQLite is \nvery carefully tested prior to every\nrelease and has a reputation for being very reliable.\nMost of the SQLite source code is devoted purely to testing and\nverification.  An automated test suite runs millions and millions of\ntest cases involving hundreds of millions of individual SQL statements\nand achieves 100% branch test coverage.  \nSQLite responds gracefully to memory\nallocation failures and disk I/O errors.  Transactions are\nACID\neven if interrupted by system crashes or power failures.  \nAll of this is verified by\nthe automated tests using special test harnesses which simulate \nsystem failures.\nOf course, even with all this testing, there are still bugs.\nBut unlike some similar projects (especially commercial competitors)\nSQLite is open and honest about all bugs and provides\nbugs lists and\nminute-by-minute \nchronologies of code changes.\nThe SQLite code base is supported by an\ninternational team of developers who work on\nSQLite full-time.\nThe developers continue to expand the capabilities of SQLite\nand enhance its reliability and performance while maintaining\nbackwards compatibility with the \npublished interface spec,\nSQL syntax, and database file format.\nThe source code is absolutely free to anybody who wants it,\nbut professional support is also available.\nThe SQLite project was started on \n2000-05-09.\nThe future is always hard to predict, but the intent of the developers\nis to support SQLite through the year 2050.  Design decisions are made\nwith that objective in mind.\nWe the developers hope that you find SQLite useful and we\nentreat you to use it well: to make good and beautiful products that\nare fast, reliable, and simple to use.  Seek forgiveness for yourself\nas you forgive others.  And just as you have received SQLite for free,\nso also freely give, paying the debt forward.\nThis page last modified on  2023-10-10 17:29:48 UTC \n", "media": "\n\n\n\n\nRecent SQLite News\n\n\n\n\n\n\n\n\n\nSmall. Fast. Reliable.Choose any three.\n\n\n\nHome\nMenu\nAbout\nDocumentation\nDownload\nLicense\nSupport\nPurchase\n\nSearch\n\n\n\n\nAbout\nDocumentation\nDownload\nSupport\nPurchase\n\n\n\n\n\nSearch Documentation\nSearch Changelog\n\n\n\n\n\n\n\nRecent News\n2025-02-18 - Version 3.49.1\nPatch release 3.49.1 fixes a a problem in the concat_ws() SQL function.\nThe problem has existed since version 3.44.0 (2023-11-01) but was\nonly discovered two days ago.  The problem is a potential vulnerability.\nAn attacker who can control the separator string and can make that\nstring very large (hundreds of megabytes) could cause a memory error.\nYour system is not vulnerable if you following the \nrecommended application security practices, especially recommendation\nnumber 2, or if your system does not use the concat_ws() function and\nis impervious to SQL injections.  Regardless of whether or not your\nsystem is subject to this problem, you will do well to upgrade to version\n3.49.1 or later.\n\nThe 3.49.1 patch release also makes multiple improvements to the portability\nof configure scripts and makefiles.  These improvements involve\na lot of change, but only to makefiles and configuration scripts.  The \ncore SQLite library is unaffected by those enhancements.\n2025-02-06 - Version 3.49.0\nThere were a lot of minor patches and bug fixes that needed to be added\nto the 3.48.0 release.  We were originally planning to do a patch release\n3.48.1 to publish those changes.  But we noticed that the patches formed\na significant fraction of all changes on the main development trunk, and\nthe trunk was stable, so we decided instead just to\ndo an early release of version 3.49.0.\n\nHence, the 3.49.0 release is being published less than one month after\nthe 3.48.0 release.  Version 3.49.0 contains both patches for minor\nissues in the 3.48.0 release and new enhancements.\nSee the change log for details.\n\nWe expect that the next major release (3.50.0) will resume the usual\n5-to-7 month cadence.\n2025-01-14 - Version 3.48.0\nVersion 3.48.0 refactors the \"./configure\" system of SQLite to fix bugs,\nsimplify usage, improve performance, and make it easier to maintain moving\nforward.  Though the internal changes are extensive, the user interface\nshould remain the same.  Unless you were doing something bizarre and\nundocumented with ./configure, you should not notice the difference.\n\nNB: This change applies to the configure system in the\ncanonical source code only.  The amalgamation tarball\n(the sqlite-autoconf-xxxxxx.tar.gz download) is unaffected.\n\nThe ./configure implementation has changed to use\nAutosetup instead of\nGNU Autoconf.  One benefit of this is that TCL is no longer necessary\nto build SQLite from canonical sources, thus simplifying the build\nprocess.  Just download the canonical source code, unpack it, and\nrun \"./configure && make\".  No third-party software packages (other\nthan the C compiler and related tools like \"make\") are needed in\nmost cases.  The Windows makefile (\"Makefile.msc\") also now\nruns without TCL.  Note, however, that TCL is still required to run\ntests or to build tools such as sqlite3_analyzer that link against\nlibtcl.\n\nThere are other minor enhancements in the 3.48.0 release, but the\nrefactor of the ./configure system is by far the biggest and most\nimportant change.  See the change log for more detail.\n2024-12-07 - Version 3.47.2\nVersions 3.47.0 and 3.47.1 contain a bug in the text-to-floating-point\nconversion routines such that numbers where the 16\nmost significant digits are \"1844674407370955\" might be converted to\nfloating point incorrectly on x64 and i386 hardware.  This is not an\nissue on ARM or PPC (the only other CPUs that the SQLite devs have\naccess to), only x64/i386.\nVersion 3.47.2 addresses the problems.  You should upgrade to\n3.47.2 or later if you are using any prior 3.47.x release.\n2024-11-25 - Version 3.47.1\nVersion 3.47.1 is a patch release with minimal changes from\nversion 3.47.0.  The purpose of the patch is to fix various\nissues in the 3.47.0 release.\n2024-10-21 - Version 3.47.0\nVersion 3.47.0 is an enhancement release with many\nfeature improments and performance enhancements.  Of particular note:\n\n The sqlite3_rsync command-line utility is now available for\n     doing bandwidth-efficient live backups over SSH.\n Integration with TCL9.\n\n\nSee the change log for details.\n2024-08-13 - Version 3.46.1\nVersion 3.46.1 is a patch release that fixes several minor\nproblems in version 3.46.0.  There are minimal changes from\nthe previous release.\n2024-05-23 - Version 3.46.0\nVersion 3.46.0 is an enhancement release.  Enhancements include:\n\n Improvements to the PRAGMA optimize command\n Enhancements to the date and time functions\n The ability to put \"_\" between digits in numeric literals for readability\n Added the json_pretty() function\n Improvements to the query planner, especially a new faster implementation\n     for VALUES clauses with many terms.\n\n\nNone of these enhancements are critical.  Update at your convenience.\n2024-04-15 - Version 3.45.3\nVersion 3.45.3 is a patch release that fixes a few obscure problems,\nincluding:\n\n The \"old.*\" values in an UPDATE trigger might be incorrect\n     if the trigger fires in response to an UPSERT.\n The sum() function might return NULL in some cases where Infinity\n     would be a better answer.\n\nNone of the problems are emergencies.  Upgrade at your convenience.\n2024-03-12 - Version 3.45.2\nVersion 3.45.2 is a patch against SQLite versions 3.45.0 and 3.45.1.\n\nThe primary reason for this patch is to fix two bugs three-year-old\nbugs identified by Forum posts\n919c6579c8\nand 440f2a2f17.\nThese problems could results in incorrect query results or corrupt\nindexes.  See the associated forum threads for details.\n\nOther trifling fixes are also included in the patch.\n2024-01-30 - Version 3.45.1\nVersion 3.45.1 is a patch against SQLite version 3.45.0.\n\nThe main focus of this patch release is to restore certain\nundocumented legacy behavior in the JSON SQL functions that\nthe developers were unaware of but which some applications\nhad come to depend on.  This undocumented behavior was \"fixed\"\nin the 3.45.0, resulting in breakage for applications that were\nusing it.  So it has now been restored and documented.\n\nOther obscure issues that have come up since the 3.45.0 release,\nsome related to the release itself and some going back years,\nare also fixed.\n2024-01-15 - Version 3.45.0\nVersion 3.45.0 is an enhancement release of SQLite.\n\nThe most impactful change is likely enhancements to\nthe JSON SQL functions such that they are now able to\nstore their internal JSON parse trees in the database\nas BLOB values.  This can significantly increase the\nperformance of applications that process large JSON\nstrings as it omits the need to translate JSON text\nto and from the internal binary format used by SQLite.\n\nA second noteworthy change is that any\napplication-defined SQL functions that make use of\nthe sqlite3_result_subtype() interface must now include\nthe SQLITE_RESULT_SUBTYPE attribute when the function\nis registered using sqlite3_create_function() or similar.\nFailure to include the SQLITE_RESULT_SUBTYPE attribute on\nfunctions that use sqlite3_result_subtype() might result\nin incorrect answers.\n\nSee the change log\nfor additional enhancements that are part of the 3.45.0 release.\n2023-11-24 - Version 3.44.2\nThe CLI fix in version 3.44.1 introduced a new bug, which is\nfixed by patch release 3.44.2.  Version 3.44.2 also fixes an\nFTS5 problem that was found by a fuzzer just minutes after the\n3.44.1 release.\n2023-11-22 - Version 3.44.1\nVersion 3.44.1 is a patch release that fixes various obscure\nbugs.  There is no need to upgrade, unless you are having\nproblems with a prior release.\n2023-11-01 - Version 3.44.0\nVersion 3.44.0 is new enhancement release of SQLite.\n\nIt has only been 69 days since the previous major\nrelease (3.43.0).  The original plan was for version 3.44.0\nto occur at a spacing of approximately 120 days from the\nprior release.  However, the code accumulated so many important\nenhancements that is seemed better to accelerate the release\nof 3.44.0, thus getting those enhancements into circulation.\nThis means that some enhancements that where originally\nplanned to be in 3.44.0 have been deferred until subsequent\nreleases.\n2023-10-10 - Version 3.43.2\nVersion 3.43.2 is a patch release that fixes a few small inaccuracies in\nversion 3.43.0 and 3.43.1.\n2023-09-11 - Version 3.43.1\nVersion 3.43.1 is a patch release that fixes a few small inaccuracies that were\ndiscovered in the the 3.43.0 and/or 3.42.0 releases after the 3.43.0 release was\npublished.\n2023-08-24 - Version 3.43.0\nVersion 3.43.0 is a routine enhancement release of SQLite.\nKey enhancements in this release include added support for\nContentless-Delete FTS5 Indexes, \nand performance improvements in JSON processing.\nSee the change log for\ndetails.\n2023-05-16 - Version 3.42.0\nVersion 3.42.0 is a routine enhancement release of SQLite.\nKey enhancements in this release are added support for\nJSON5 and the FTS5 secure-delete command.  See the\nchange log for a\nsummary of all enhancements in this release.\n2023-03-22 - Version 3.41.2\nVersion 3.41.2 is a patch release that fixes multiple\nfuzzer-found problems in prior releases.  The worst problems\ninclude reads (not writes) past the end of a buffer.  Upgrading\nis recommended.\n2023-03-10 - Version 3.41.1\nVersion 3.41.1 is a patch release that fixes various obscure\nproblems found in 3.41.0 and reported by users.  Upgrading\nis optional.\n2023-02-21 - Version 3.41.0\nVersion 3.41.0 is a routine enhancement release.\n2022-12-28 - Version 3.40.1\nVersion 3.40.1 is a patch release that fixes some obscure problems\nin version 3.40.0.  The problems fixed have no impact on most applications.\nUpgrading is only necessary if you encounter problems.\n\nThe two most important fixes are these:\n\n\nFix the safe command-line option on the CLI so that it\ncorrectly disallows functions with side-effects.  This is a bug\nin the CLI \u2014 not a bug in the\nSQLite library \u2014 and it only affects the --safe command-line\noption, making that option less than fully \"safe\".  As the number\nof systems that use the --safe command-line option in the CLI is\napproximately zero, this is not considered an important bug.  However,\na third-party wrote a CVE against it which caused considerable angst\namong maintainers, so it seems good to get the fix into circulation\nsooner rather than wait on the next major release.\n\nThe optional memsys5 memory allocator picked up a bug that might\nput it into an infinite loop for very large (500MiB) allocations.\nAlmost all systems use their native memory allocator, not memsys5.\nMemsys5 is only used if SQLite is compiled using SQLITE_ENABLE_MEMSYS5\nand then initialized using sqlite3_config(SQLITE_CONFIG_HEAP).\nVery, very few systems do this, and so the problem is not considered\nto be serious.\n\n\nSee the branch-3.40 timeline\nfor a complete listing of changes that have gone into this patch release.\n2022-11-16 - Version 3.40.0\nVersion 3.40.0 is a new feature release of SQLite.  See the\nchange log for details.\nKey enhancements in this release include:\n\n\nOfficial support for compiling \nSQLite to WASM\nand running it in a web browser.\n\nNew and improved recovery extension for extracting\ndata from corrupted database files.\n\n\nThis release also includes performance enhancements and\nimprovements to the query planner.\n\nA psychological milestone:  The performance benchmark that\nthe SQLite developers have used for many years has for\nthe first time dropped below 1 billion CPU cycles\n(measured using cachegrind) when run in WAL mode.\nThis is less than half the number of CPU cycles used as\nrecently as 8 years ago.  (The graph below shows SQLite using\na rollback journal which uses fewer CPU cycles at the expense\nof extra I/O.  The benchmark passed through the 1 billion cycle\nbarrier for rollback journals for the previous release.)\n\n\n\n2022-09-29 - Version 3.39.4\nVersion 3.39.4 is a security release that addresses a single\nlong-standing problem in the FTS3 extension.  An attacker\nwho is able to execute arbitrary SQL statements and who can create\na corrupt database that is 2GB or larger in size might be able to trick\nFTS3 into overflowing an integer used to size a memory allocation,\ncausing the allocation to be too small and ultimately resulting in\na buffer overrun.  The release also includes fixes for other\nobscure weaknesses, as described in the release notes.\n2022-09-05 - Version 3.39.3\nVersion 3.39.3 is a patch release that fixes a few obscure problems\nin the 3.39.0 release.  See the release notes for details.\n2022-07-21 - Version 3.39.2\nVersion 3.39.2 is a security release that addresses multiple long-standing\nissues in SQLite.  The most severe problem is identified by CVE-2022-35737.\nThat issue is associated with the auxiliary C-language APIs\nof SQLite and cannot be reached using SQL or database inputs, and hence is\nunlikely to affect your application.  Nevertheless, upgrading is recommended.\nThe other issues are comparatively minor.\nThis release also fixes a performance regression that appeared in version\n3.39.0 that might affect some multi-way joins that use LEFT JOIN.\n2022-07-13 - Version 3.39.1\nVersion 3.39.1 is a patch release that fixes a few minor problem in version\n3.39.0.  Upgrading is optional.\n2022-06-25 - Version 3.39.0\nVersion 3.39.0 is regular maintenance release of SQLite.  The key enhancement\nin this release is added support for RIGHT and FULL JOIN.  There are other\nlanguage and performance enhancements as well \u2014 see the\nrelease notes for details.\n2022-05-06 - Version 3.38.5\nThe 3.38.4 patch release included a minor change to the CLI source code\nthat did not work.  The release manager only ran a subset of the normal\nrelease tests, and hence did not catch the problem. As a result, the CLI\nwill segfault when using columnar output modes in version 3.38.4.  This\nblunder did not affect the core SQLite library.  It only affected the CLI.\n\nTake-away lesson:  Always run all of your tests prior to\na release - even a trival patch release.  Always.\n\nThe 3.38.5 patch release fixes the 3.38.4 blunder.\n2022-05-04 - Version 3.38.4\nAnother user-discovered problem in the new Bloom filter optimization\nis fixed in this patch release.  Without the fix, it is possible for\na multi-way join that uses a Bloom filters for two or more tables in\nthe join to enter an infinite loop if the key constraint on one of those\ntables contains a NULL value.\n2022-04-27 - Version 3.38.3\nVersion 3.38.3 fixes a bug in the automatic-index and Bloom filter\nconstruction logic that might cause SQLite to be overly aggressive\nin the use of ON clause constraints, resulting in an incorrect\nautomatic-index or Bloom filter that excludes some valid rows from\noutput.  The bug was introduced in version 3.38.0.  Other minor\nchanges were tossed in to complete the patch.\n2022-03-26 - Version 3.38.2\nVersion 3.38.2 fixes another bug in the new Bloom filter\noptimization that might cause incorrect answers for a\nLEFT JOIN that has an IS NULL constraint on the right-hand\ntable.\n2022-03-12 - Version 3.38.1\nVersion 3.38.1 fixes a pair of bugs in the Bloom filter\noptimization that was introduced in version 3.38.0.  These\nbugs might cause incorrect answers for some obscure queries.\nVarious other minor problems and documentation typos were\nfixed at the same time.\n2022-02-22 - Version 3.38.0\nVersion 3.38.0 is a routine maintenance release of\nSQLite.  There are various minor enhancements and\nabout a 0.5% reduction in the number of CPU cycles\nused. See the\nrelease notes for\nmore detail.\n2022-01-06 - Version 3.37.2\nVersion 3.37.2 fixes a\ndatabase corruption bug.  You are\nencouraged to upgrade, especially if you are using SAVEPOINT.\nThe problem first appeared in version 3.35.0 (2021-03-12) and\naffects all subsequent releases through 3.37.1.\nIf temporary files are store in memory (which is not the default\nbehavior, but is sometimes selected by applications using either\n-DSQLITE_TEMP_STORE or PRAGMA temp_store) and\nif a SAVEPOINT is rolled back and then subsequent changes\nwithin the same transaction are committed, the database file might\n(with low but non-zero probability) go corrupt.\n2021-12-30 - Version 3.37.1\nVersion 3.37.1 fixes a bug in the UPSERT logic, introduced by\nthe UPSERT enhancements of version 3.35.0, that can cause\nincorrect byte-code to be generated in some cases, resulting\nin an infinite loop in the byte code, or a NULL-pointer dereference.\nThis patch release also fixes some other minor problems with\nassert() statements and in the CLI.\n2021-11-27 - Version 3.37.0\nVersion 3.37.0 is a routine maintenance release of SQLite.\nThe biggest new feature in this release is support for\nSTRICT tables.  Other enhancements are described in\nthe release notes.\n2021-06-18 - Version 3.36.0\nVersion 3.36.0 is a routine maintenance release of SQLite.\nThere are no new major features, only incremental improvements\nto existing features and small performance improvements.\n2021-04-19 - Patch release 3.35.5\nThe new ALTER TABLE DROP COLUMN capability that was added\nin the 3.35.0 release contained a bug that might cause the\ntable content to go corrupt when the table was rewritten\nto remove the dropped column.  Fixed by this patch.\n2021-04-02 - Patch release 3.35.4\nVersion 3.35.4 is yet another patch release to fix\nobscure problems in features associated with the 3.35.0.\n2021-03-26 - Patch release 3.35.3\nVersion 3.35.3 contains patches for a handful of minor\nproblems discovered in prior releases.\n2021-03-17 - Patch release 3.35.2\nVersion 3.35.2 is a small patch release to fix some minor problems\nthat were discovered shortly after the 3.35.1 release.\n2021-03-15 - Patch release 3.35.1\nA user discovered an issue with the new DROP COLUMN capability\nin version 3.35.0, and so version 3.35.1 was created to fix it.\nNo need to upgrade if you are not using DROP COLUMN.\n2021-03-12 - Release 3.35.0\nSQLite version 3.35.0 is a routine maintenance release.  This\nrelease adds a number of new language features, including\nsupport for ALTER TABLE DROP COLUMN, built-in math functions,\ngeneralized UPSERT, and the MATERIALIZED hint on common table\nexpressions.  There are also query planner optimizations and\nincremental CLI improvements.\n2020-01-20 - Release 3.34.1\nSQLite version 3.34.1 is a patch releases that fixes a possible\nuse-after-free bug that can be provoked by malicious SQL.  Other\nminor issues in extensions and documentation are also fixed.\n2020-12-01 - Release 3.34.0\nSQLite version 3.34.0 is a routine maintenance release.  This\nrelease adds incremental improvements to performance and features,\nincluding enhancements to the query planner, multiple recursive\nSELECTS in recursive common table expressions, and better error messages\nfrom CHECK constraint failures.  See the change log for details.\n2020-08-14 - Release 3.33.0\nSQLite version 3.33.0 is a routine maintenance release.  This\nrelease features added support for \"UPDATE FROM\" following the\nPostgreSQL syntax, and a doubling of the maximum database size\nto 281 TB, as well as many other improvements.  See the change\nlog for details.\n2020-06-18 - Release 3.32.3\nThe 3.32.3 release is a patch release that contains fixes for\nvarious issues discovered by fuzzers.  None of the issues fixed\nare likely to be encountered by applications that use SQLite in\nordinary ways, though upgrading never hurts.\n\nMap of all changes since the 3.32.0 release:\nhttps://www.sqlite.org/src/timeline?p=version-3.32.3&bt=version-3.32.0\n2020-06-04 - Release 3.32.2\nThe 3.32.2 release is a one-line change relative to 3.32.1\nthat fixes a long-standing bug in the COMMIT command.  Since\nversion 3.17.0, if you were to retry a COMMIT command over\nand over after it returns SQLITE_BUSY, it might eventually\nreport success, even though it was still blocked.  This patch\nfixes the problem.\n2020-05-25 - Release 3.32.1\nGrey-hats published\ninformation about two SQLite bugs approximately 24 hours after\nthe release of version 3.32.0.  These bugs enable maliciously\ncrafted SQL to crash the process that is running SQLite.  Both\nbugs are long-standing problems that affect releases prior to\n3.32.0. The 3.32.1 release fixes both problems.\n2020-05-22 - Release 3.32.0\nVersion 3.32.0 is an ordinary maintenance release of SQLite.\nThis release features the ability to run an\napproximate ANALYZE to gather database statistics for\nuse by the query planner, without having to scan every row\nof every index.\nSee the change log for additional enhancements\nand improvements.\n2020-01-27 - Release 3.31.1\nApplications that use SQLite should only interface with SQLite\nthrough the officially published APIs.  Applications should not\ndepend upon or use the internal data structures of SQLite as those\nstructures might change from one release to another.  However, there\nis a popular application that does depend on the details of the\ninternal layout of data in an internal SQLite data structure, and\nthose details changed in version 3.31.0, breaking the application.\nThis is, technically, a bug in the application, not in SQLite.\nBut it is within the power of SQLite to fix it, by reverting the\ninternal data structure change, and so that is what we have done\nfor the 3.31.1 release.\n2020-01-22 - Release 3.31.0\nVersion 3.31.0 is an ordinary maintenance release of SQLite.\nThis release features the ability to define\ngenerated columns for tables as well as many other enhancements.\nSee the change log for additional information.\n2019-10-11 - Release 3.30.1\nVersion 3.30.1 is a bug-fix release that addresses a problem\nthat can occur when an aggregate function in a nested query\nmakes use of the new FILTER clause capability.  Some addition\npatches for various obscure issues are also included, for\ncompleteness.\n2019-10-04 - Release 3.30.0\nVersion 3.30.0 is a regularly scheduled maintenance release\nof SQLite containing miscellaneous performance and feature\nenhancements.  This release adds support fo the NULLS FIRST\nand NULLS LAST clauses on ORDER BY statements and the \naddition of FILTER clauses on all aggregate functions.\nSee the change log for details.\n2019-07-10 - Release 3.29.0\nVersion 3.29.0 is a regularly scheduled maintenance release\nof SQLite containing miscellaneous performance and feature\nenhancements.  See the change log for\ndetails.\n\nBeginning with this release, the\ndouble-quoted string literal misfeature is deprecated.\nThe misfeature is still enabled by default, for legacy\ncompatibility, however developers are encouraged to\ndisable it at compile-time using the\n-DSQLITE_DQS=0 option, or at run-time using\nthe SQLITE_DBCONFIG_DQS_DML and SQLITE_DBCONFIG_DQS_DDL\nactions to the sqlite3_db_config() interface.  This is\nespecially true for double-quoted string literals in\nCREATE TABLE and CREATE INDEX statements, as those elements\ncan cause unexpected problems following an ALTER TABLE.\nSee ticket 9b78184be266fd70\nfor an example.\n2019-04-16 - Release 3.28.0\nVersion 3.28.0 is a regularly scheduled maintenance release\nof SQLite containing miscellaneous performance and feature\nenhancements.  See the change log for\ndetails.\n\nThis release fixes an obscure security issue. Applications\nusing older versions of SQLite may be vulnerable if\n\n SQLite is compiled with certain optional extensions\n     enabled, and\n the attacker is able to inject arbitrary SQL.\n\nWe are not aware of any applications that are vulnerable to\nthis problem. On the other hand, we do not know about\nevery application that uses SQLite.  \nIf your application allows unauthenticated users on the internet\n(and hence potential attackers) to run arbitrary SQL and if\nyou build SQLite with any of the optional extensions enabled,\nthen you should take this upgrade at your earliest opportunity.\n\nFor further information about improving SQLite's robustness\nin internet-facing applications, see the our\nsecurity recommendations.\n2019-02-25 - Release 3.27.2\nVersion 3.27.2 is a patch release that\nfixes a two bugs and various documentation\nerrors found in the version 3.27.1.  The\nchanges from version 3.27.1 and 3.27.0 are\nminimal.\n2019-02-08 - Release 3.27.1\nAfter release 3.27.0 was tagged, but before the build could\nbe completed and uploaded, a \nlong-standing bug\nin the query optimizer was reported via System.Data.SQLite.\nSince people will be upgrading anyhow, we decided \npublish the fix for this newly discovered problems right\naway.  Hence, 3.27.1 was released less than 24 hours after\n3.27.0.\n\nIt would have been better if the query optimizer bug had come to\nour attention one day earlier, so that we could have incorporated\na fix into 3.27.0, but sometimes that's the way things go.\n2019-02-07 - Release 3.27.0\nSQLite version 3.27.0 is a routine maintenance release with various\nperformance and feature enhancements.  See the\nrelease notes for details.\n2018-12-01 - Release 3.26.0\nSQLite version 3.26.0 is a routine maintenance release with various\nperformance and feature enhancements.  See the\nrelease notes for details.\n2018-11-05 - Release 3.25.3\nSQLite version 3.25.3 is a third patch against 3.25.0 that fixes various\nproblems that have come to light and which seem serious enough to \njustify a patch.\n2018-09-25 - Release 3.25.2\nSQLite version 3.25.2 is another patch against 3.25.0 that fixes still\nmore problems associated with the new window function feature and the\nALTER TABLE enhancements.  Of particular note is the new\nPRAGMA legacy_alter_table=ON command, which causes the ALTER TABLE RENAME\ncommand to behave in the same goofy way that it did before the enhancements\nfound in version 3.25.0 \u2192 references to renamed tables that are inside\nthe bodies of triggers and views are not updated.  The legacy behavior is\narguably a bug, but some programs depend on the older buggy behavior.  The\n3.25.2 release also contains a fix to window function processing for\nVIEWs.  There also a slew of other minor fixes that affect obscure\ncompile-time options.  See the\nFossil Timeline for\ndetails.\n2018-09-18 - Release 3.25.1\nSQLite version 3.25.1 is a patch against version 3.25.0 that contains\ntwo one-line fixes for bug that were introduced in version 3.25.0.\nSee the change log for details.  Upgrading from 3.25.0 is recommended.\n2018-09-15 - Release 3.25.0\nSQLite version 3.25.0 is a regularly scheduled maintenance release.\nTwo big enhancements in this release:\n\n\nSupport for window functions was added, using the PostgreSQL documentation\nas the baseline.\n\nThe ALTER TABLE command was enhanced to support renaming of columns, and\nso that column and table renames are propagated into trigger bodies and views.\n\nIn addition, there are various performance enhancements and minor fixes.\nOne bug of note is \nticket 9936b2fa443fec\nwhich describes a hard-to-reach condition where the ORDER BY LIMIT\noptimization might cause an infinite loop during query evaluation.  \nThis ticket raised a lot of\nconcern on \nHackerNews and\nReddit,\nprobably due to my choice of the ticket\ntitle.  \"Infinite Loop\" sounds scary.  But I argue that the bug isn't really\nall that bad in that it is very difficult to reach, will show up during\ntesting (rather than magically appearing after a product is\ndeployed), does not cause any data loss, and does not return an\nincorrect result.  It was an important error, but not nearly as dire\nas many people interpreted it to be.  And, in any event, it is fixed now.\n2018-06-04 - Release 3.24.0\nSQLite version 3.24.0 is a regularly scheduled maintenance release.\nHighlights of this release include support for PostgreSQL-style\nUPSERT and improved performance, especially for ORDER BY LIMIT queries.\n2018-04-10 - Release 3.23.1\nThe version 3.23.1 release fixes a bug in the new\nLEFT JOIN strength reduction optimization added to version 3.23.0.\nA few other minor and obscure fixes were also inserted, as well as\na small performance optimization.  Code changes relative to\nversion 3.23.0 are minimal.\n2018-04-02 - Release 3.23.0\nThe version 3.23.0 release is a regularly scheduled maintenance release.\nSee the change log for a list of enhancements and bug\nfixes.\n2018-01-22 - Release 3.22.0\nThe version 3.22.0 release is a regularly scheduled maintenance release.\nThere are many minor, though interesting, enhancements in this release.\nSee the change log for details.\n2017-10-24 - Release 3.21.0\nThe version 3.21.0 release is a regularly scheduled maintenance release.\nThere are lots of enhancements in this release.\nSee the change log for details.\n2017-08-24 - Release 3.20.1\nThe version 3.20.1 patch release changes two lines of code in\nthe sqlite3_result_pointer() interface in order to fix a rare\nmemory leak.  There are no other changes relative to version 3.20.0.\n2017-08-01 - Release 3.20.0\nSQLite version 3.20.0 is a regularly scheduled maintenance release\nof SQLite.\n\nThis release contains many minor enhancements, including:\n\n Several new extensions\n Enhancements to the \"sqlite3.exe\" command-line shell\n Query planner enhancements\n Miscellaneous code optimizations for improved performance\n Fixes for some obscure bugs\n\n\nSee the release notes for more information.\n2017-06-17 - Release 3.18.2\nSQLite version 3.18.2 is another backport of a bug fix found\nin SQLite version 3.19.0, specifically the fix for\nticket 61fe9745.  Changes\nagainst version 3.18.0 are minimal.\n2017-06-16 - Release 3.18.1\nSQLite version 3.18.1 is a bug-fix release against version 3.18.0\nthat fixes the auto_vacuum corruption bug described in ticket\nfda22108.  This release was\ncreated for users who need that bug fix but do not yet want to upgrade \nto version 3.19.3.  \n2017-06-08 - Release 3.19.3\nVersion 3.19.3 is an emergency patch release to fix a \nbug in \nauto_vacuum logic that can lead to database corruption.\nThe bug was introduced in version 3.16.0 \n(2017-01-02).  Though the bug is obscure and rarely\nencountered, upgrading is recommended for all users, and\nespecially for users who turn on auto_vacuum.\n2017-05-25 - Release 3.19.2\nStill more problems have been found in the LEFT JOIN\nflattening optimization\nthat was added in the 3.19.0 release.  This patch release fixes all known\nissues with that optimization and adds new test cases.  Hopefully this\nwill be the last patch.\n2017-05-24 - Release 3.19.1\nOne of the new query planner optimizations in the 3.19.0 release contained\nbugs.  The 3.19.1 patch release fixes them.\n\nBeginning with 3.19.0, subqueries and views on the right-hand side of\na LEFT JOIN operator could sometimes be\nflattened into the\nmain query.  The new optimization worked well for all of the test cases\nthat the developers devised, and for millions of legacy test cases, but\nonce 3.19.0 was released, users found some other cases where the optimization\nfailed.  Ticket\ncad1ab4cb7b0fc344 contains\nexamples.\n\nThese problems exist only in 3.19.0.  Users of SQLite 3.19.0 should\nupgrade, but users of all prior versions of SQLite are safe.\n2017-05-22 - Release 3.19.0\nSQLite version 3.19.0 is a regularly scheduled maintenance release.\n\nThe emphasis on this release is improvements to the query planner.\nThere are also some obscure bug fixes.  There is no reason to upgrade\nunless you are having problems with a prior release.\n2017-03-30 - Release 3.18.0\nSQLite version 3.18.0 is a regularly scheduled maintenance release.\n\nThis release features an initial implementation the \n\"PRAGMA optimize\" command.  This command can now be used to cause\nANALYZE to be run on an as-needed basis.  Applications should invoke\n\"PRAGMA optimize\" just before closing the database connection.\nThe \"PRAGMA optimize\" statement will likely be enhanced to do other\nkinds of automated database maintenance in future releases.\n\nThe Fossil version control system that is\nused to manage the SQLite project has been upgraded to use SHA3-256 hashes\ninstead of SHA1.  Therefore, the version identifications for SQLite now\nshow a 64-hex-digit SHA3-256 hash rather than the 40-hex-digit SHA1 hash.\n\nSee the change log for other enhancements and optimizations\nin this release.\n2017-02-13 - Release 3.17.0\nSQLite version 3.17.0 is a regularly scheduled maintenance release.\n\nMost of the changes in this release are performance optimizations.\nOptimizations to the R-Tree extension are especially noticeable.\n\nIn this release, the default size of the \nlookaside buffer allocated for each database connection\nis increased from 64,000 to 120,000 bytes.  This provides improved\nperformance on many common workloads in exchange for a small increase\nin memory usage.\nApplications that value a small memory footprint over raw speed\ncan change the lookaside buffer size back to its old value (or to zero)\nusing the SQLITE_DEFAULT_LOOKASIDE compile-time option, or the\nsqlite3_config(SQLITE_CONFIG_LOOKASIDE)\nstart-time setting, or the\nsqlite3_db_config(SQLITE_DBCONFIG_LOOKASIDE)\nrun-time setting.\n2017-01-06 - Release 3.16.2\nOne of the performance optimizations added in 3.16.0 caused triggers\nand foreign keys to malfunction for the REPLACE statement on\nWITHOUT ROWID tables that lack secondary indexes.  This patch\nrelease fixes the problem.  See ticket \n30027b613b4 for details.\n2017-01-03 - Release 3.16.1\nSQLite version 3.16.1 fixes a bug in the row-value logic for UPDATE\nstatements inside of triggers.  The bug has been there since row-values\nwere added by release 3.15.0, but was not discovered until just a few\nminutes after the 3.16.0 release was published, and so it was not fixed\nby 3.16.0.  This patch release is version 3.16.0 with the row-value bug fix.\n2017-01-02 - Release 3.16.0\nSQLite version 3.16.0 is a regularly schedule maintenance release.\n\nThis release includes many microoptimizations that collectively reduce\nthe CPU cycle count by about 9%,\nadd there have been important enhancements to the command-line shell.\nSupport for PRAGMA functions is added,\nso that many pragma statements can be used as part of a larger SQL query.\nThis is considered an experimental feature.\nWe do not anticipate any changes to the PRAGMA function interface, but\nwill keep continue to call this interface \"experimental\" for a few release\ncycles in case unforeseen issues arise.\nSee the change log for other enhancements.\n2016-11-28 - Release 3.15.2\nSQLite version 3.15.2 is a bug-fix patch release that fixes several minor\nissues in the 3.15.0 and 3.15.1 releases.\n2016-11-04 - Release 3.15.1\nSQLite version 3.15.1 is a bug-fix patch release that fixes some minor\nissues in the 3.15.0 release.\n2016-10-14 - Release 3.15.0\nSQLite version 3.15.0 is a regularly scheduled maintenance release.\nThe key feature in this release is the added support for\nrow values.  There are also other enhancements and\nfixes for a number of obscure bugs.\n\nThe 3.15.0 release uses about 7% fewer CPU cycles than 3.14.2.\nMost of the improvement in this release\nis in the SQL parser, query planner, and\nbyte-code generator (the front-end) corresponding\nto the sqlite3_prepare_v2() interface.  Overall,\nversion 3.15.0 uses about half as much CPU time as\nversion 3.8.1 (2013-10-17).  These\nperformance measurements are made using the \"speedtest1.c\"\nworkload on x64 compiled with gcc and -Os. Performance\nimprovements may vary with different platforms and\nworkloads.\n2016-09-12 - Release 3.14.2\nSQLite version 3.14.2 fixes several obscure bugs and adds \nimproved support for building SQLite using the STDCALL calling\nconvention on 32-bit windows systems.  Upgrading from versions\n3.14 and 3.14.1 is optional.\n2016-08-11 - Release 3.14.1\nSQLite version 3.14.1 adds a small patch to improve the performance\nof the pcache1TruncateUnsafe() routine for cases when the only a few\npages on the end of the cache are being removed.  This causes COMMITs\nto run faster when there is a very large page cache.  Upgrading from\nversion 3.14 is optional.\n2016-08-08 - Release 3.14\nSQLite version 3.14 (the \"\u03c0\" release)\nis a regularly scheduled maintenance\nrelease containing performance enhancements, new features, and fixes for\nobscure bugs.\n2016-05-18 - Release 3.13.0\nSQLite version 3.13.0 is a regularly schedule maintenance release containing\nperformance enhancements and fixes for obscure bugs.\n2016-04-18 - Release 3.12.2\nYikes!  The 3.12.0 and 3.12.1 releases contain a backwards compatibility bug!\n   Tables that declare a column with type \"INTEGER\" PRIMARY KEY\n   (where the datatype name INTEGER is quoted) generate an incompatible\n   database file.  The mistake came about because the developers have never\n   thought to put a typename in quotes before, and so there was no documentation \n   of that capability nor any tests.  (There are tests now, though, of course.)\n   Instances of quoting the datatype name are probably infrequent in the wild,\n   so we do not expect the impact of this bug to be too severe.\n   Upgrading is still strongly recommended.\nFixes for three other minor issues were included in this patch release.\n   The other issues would have normally been deferred until the next scheduled\n   release, but since a patch release is being issued anyhow, they might as\n   well be included.\n2016-04-08 - Release 3.12.1\nSQLite version 3.12.1 is an emergency patch release to address a \n   crash bug that snuck\n   into version 3.12.0.  Upgrading from version 3.12.0 is highly\n   recommended.\nAnother minor problem involving datatypes on view columns, and\n   a query planner deficiency are fixed at the same time.  These two\n   issues did not justify a new release on their own, but since a release\n   is being issued to deal with the crash bug, we included these other\n   fixes for good measure.\n2016-03-29 - Release 3.12.0\nSQLite version 3.12.0 is a regularly scheduled maintenance release.\n   A notable change in this release is an\n   increase in the default page size for newly created database files.\n   There are also various performance improvements.\n   See the change log for details.\n2016-03-03 - Release 3.11.1\nSQLite version 3.11.1 is a patch release that fixes problems in the\n   new FTS5 extension and increases a default setting in the spellfix1\n   extension, and implements enhancements to some of the Windows makefiles.\n   The SQLite core is unchanged from 3.11.0. Upgrading is optional.\n2016-02-15 - Release 3.11.0\nSQLite version 3.11.0 is a regularly scheduled maintenance release.\n2016-01-20 - Release 3.10.2\nYikes!  An optimization attempt gone bad resulted in a \nbug in the LIKE operator\nwhich is fixed by this patch release.\nThree other minor but low-risk fixes are also included in the patch.\n2016-01-14 - Release 3.10.1\nSQLite version 3.10.1 is a bug-fix release primarily targeting the\nfix for the query planner bug\ncb3aa0641d9a4 discovered by\nMapscape.  Also included is a minor API enhancement requested by\nthe Firefox developers at Mozilla.  The differences from version \n3.10.0 are minimal.\n2016-01-06 - Release 3.10.0\nSQLite version 3.10.0 is a regularly scheduled maintenance release.\n\nOld news...\nThis page last modified on  2025-02-18 13:42:10 UTC \n"}
